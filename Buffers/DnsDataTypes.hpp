#ifndef DNSDATATYPES_HPP
#define DNSDATATYPES_HPP

#include <string>
#include <cstring>
#include <stdint.h>
#include <vector>

// Max size of UDP DNS package.
const size_t max_DNS_pkg_size = 512;

struct DnsPkgHeader
{
    /*
     * Identifier: A 16-bit identification field generated by the device that creates the
     * DNS query. It is copied by the server into the response, so it can be used by that
     * device to match that query to the corresponding reply received from a DNS server.
     * This is used in a manner similar to how the Identifier field is used in many of the
     * ICMP message types.
     */
    unsigned char ident[2] {0, 0};
    /*
     * Message flags.
     * See Dnsflag enum.
     */
    unsigned char flags[2] {0, 0};
    /*
     * QDcount
     * Question Count:
     * Specifies the number of questions in the Question section of the message.
     */
    unsigned char QDcount[2] {0, 0};
    /*
     * ANcount
     * Answer Record Count:
     * Specifies the number of resource records in the Answer section of the message.
     */
    unsigned char ANcount[2] {0, 0};
    /*
     * NScount
     * Authority Record Count:
     * Specifies the number of resource records in the Authority section of the message.
     */
    unsigned char NScount[2] {0, 0};
    /*
     * ARcount
     * Additional Record Count:
     * Specifies the number of resource records in the Additional section of the message.
     */
    unsigned char ARcount[2] {0, 0};
};

struct DnsPkgSufix
{
    // Query type: see DnsQType.
    unsigned char QType[2] {0, 0};
    // Query class. 1 by default.
    unsigned char QClass[2] {0, 1};
};

/*
 * Dnsflag describes bits in 16bits DNS flags.
 * Bits:
 * 0 - Query/Response. Differentiates between queries and responses.
 * 1-4 - Operation code. Standart query - 0.
 * 5 - AA Authoritative Answer Flag: This bit is set to 1 in a response to indicate that
 * the server that created the response is authoritative for the zone in which the domain
 * name specified in the Question section is located. If it is 0, the response is non-authoritative.
 * 6 - Truncated. When set to 1, indicates that the message was truncated due to its length being
 * longer than the maximum permitted for the type of transport mechanism used (512 bytes in UDP).
 * Need use TCP connection.
 * 7 - Recursion Desired: When set in a query, requests that the server receiving the query attempt
 * to answer the query recursively, if the server supports recursive resolution. The value of this
 * bit is not changed in the response.
 * 8 - Recursion Available: Set to 1 or cleared to 0 in a response to indicate whether the server
 * creating the response supports recursive queries. This can then be noted by the device that
 * sent the query for future use.
 * 9-11 - Reserved. Set to zero.
 * 12-16 - Error code. 0 - no error. > 0 - error.
 */
enum class DnsFlag
{
    QR = 0,
    AA = 5,
    TC = 6,
    RD = 7,
    RA = 8,
};

// Type of DNS request.
enum class DnsQType
{
    A = 1,
    PTR = 12,
    MX = 15
};

struct DnsRequest
{
    // Name for resolve.
    std::string name;
    // Domain in DNS pkg format.
    std::string DNS_name;
    // Query ID
    uint16_t id;

    DnsQType type;
    DnsPkgHeader header;
    DnsPkgSufix sufix;

    size_t size {0};
};

struct DnsAnswerEntryInfo
{
    // Entry type: see DnsQType.
    unsigned char type[2] {0, 0};
    // Entry class. 1 by default.
    unsigned char cl[2] {0, 1};

    // Entry time to live.
    unsigned char ttl[4] {0, 0, 0, 0};
    // Entry data length.
    unsigned char data_lenth[2] {0, 1};

};

struct DnsAnswerEntryInfoMX
{
      DnsAnswerEntryInfo base_info;
      unsigned char preference[2] {0, 1};
};

struct DnsAnswerEntry
{
    uint16_t preference {0};
    std::string entry;
    size_t data_lenth;

};

struct DnsRespond
{
    // Name for resolve.
    std::string name;

    // String IP.
    std::string ip;

    // IP in 4 bytes dns pkg format;
    unsigned char DNS_ip[4] {0, 0, 0, 0};

    // Query ID
    uint16_t id;

    size_t answers_count;

    std::vector<DnsAnswerEntry> ansvers;

    DnsQType type;
    DnsPkgHeader header;
    DnsPkgSufix sufix;
};

struct DnsUtils
{
    // Convert uitn value to 2bytes format for DNS package.
    static void uint16_to_DNSchar(unsigned char * ch, const uint16_t fr);

    // Convert 2 bytes from DNS package to uint format.
    static uint16_t DNSchar_to_uint16(const unsigned char * const ch);

    // Convert uitn32 value to 4bytes format for DNS package (dns ttl).
    static void uint32_to_DNSchar(unsigned char * ch, const uint32_t fr);

    // Convert 4 bytes from DNS package to uint32 format (dns ttl).
    static uint32_t DNSchar_to_uint32(const unsigned char * const ch);

    // Return
    static bool get_DNS_flag(unsigned char * const ch, const DnsFlag flag_num);

    //
    static void set_DNS_flag(unsigned char * ch, const DnsFlag flag_num, const bool flag_value);

    // Get string domain from DNS data set. Return offset first byte after reading name.

    static size_t read_domain(const void * dns_pkg, size_t start_pos, std::string & result);

    // Convert domain to package format.
    static void domain_to_DNSstr(const std::string &dname, std::string & _res);
    static std::string domain_to_DNSstr_r(const std::string &dname);

    static bool ip_to_Addr_arpa(const std::string &ip, std::string & res);
    static std::string ip_to_Addr_arpa_r(const std::string &ip);

    static uint16_t rand_DNS_qid();
};




#endif // DNSDATATYPES_HPP
