#ifndef DNSDATATYPES_HPP
#define DNSDATATYPES_HPP

#include <string>
#include <cstring>
#include <stdint.h>
#include <vector>
#include <cmath>
#include <memory>

namespace dns {

enum class DnsError
{
    noerror = 0,
    req_str_err,
    connection_err,
    no_respond,
    resolv_err,
    id_match_err,
    req_create_err,
    timeout_err
};

// Max size of UDP DNS package.
const size_t max_pkg_size = 512;

struct DnsPkgHeaderMap
{
    /*
     * Identifier: A 16-bit identification field generated by the device that creates the
     * DNS query. It is copied by the server into the response, so it can be used by that
     * device to match that query to the corresponding reply received from a DNS server.
     * This is used in a manner similar to how the Identifier field is used in many of the
     * ICMP message types.
     */
    char ident[2] {0, 0};
    /*
     * Message flags.
     * See Dnsflag enum.
     */
    char flags[2] {0, 0};
    /*
     * QDcount
     * Question Count:
     * Specifies the number of questions in the Question section of the message.
     */
    char QDcount[2] {0, 0};
    /*
     * ANcount
     * Answer Record Count:
     * Specifies the number of resource records in the Answer section of the message.
     */
    char ANcount[2] {0, 0};
    /*
     * NScount
     * Authority Record Count:
     * Specifies the number of resource records in the Authority section of the message.
     */
    char NScount[2] {0, 0};
    /*
     * ARcount
     * Additional Record Count:
     * Specifies the number of resource records in the Additional section of the message.
     */
    char ARcount[2] {0, 0};
};

/*
 * Dnsflag describes bits in 16bits DNS flags.
 * Bits:
 * 0 - Query/Response. Differentiates between queries and responses.
 * 1-4 - Operation code. Standart query - 0.
 * 5 - AA Authoritative Answer Flag: This bit is set to 1 in a response to indicate that
 * the server that created the response is authoritative for the zone in which the domain
 * name specified in the Question section is located. If it is 0, the response is non-authoritative.
 * 6 - Truncated. When set to 1, indicates that the message was truncated due to its length being
 * longer than the maximum permitted for the type of transport mechanism used (512 bytes in UDP).
 * Need use TCP connection.
 * 7 - Recursion Desired: When set in a query, requests that the server receiving the query attempt
 * to answer the query recursively, if the server supports recursive resolution. The value of this
 * bit is not changed in the response.
 * 8 - Recursion Available: Set to 1 or cleared to 0 in a response to indicate whether the server
 * creating the response supports recursive queries. This can then be noted by the device that
 * sent the query for future use.
 * 9-11 - Reserved. Set to zero.
 * 12-16 - Error code. 0 - no error. > 0 - error.
 */
enum class DnsFlag
{
    QR = 0,
    AA = 5,
    TC = 6,
    RD = 7,
    RA = 8,
};

// Type of DNS request.
enum class DnsQType
{
    A = 1,
    PTR = 12,
    MX = 15
};


struct DnsPkgHeader
{
    // Pkg ID.
    uint16_t id;
    // Flags section:
    // Request/respond flag.
    bool f_req_resp {false};
    // 4 bits! Standart 0 (default).
    uint8_t optcode {0};
    // Authoritative Answer.
    bool f_auth_answer {false};
    // Truncation - message was truncated (if out of max pkg size. 512 bytes in udp).
    bool f_truncated {false};
    // Recursion Desired. Ask server to do query recursively.
    bool f_recursive_d {false};
    // Recursion Available. Recursive query support (in server respond).
    bool f_recursive_avail {false};
    // Error code. 0 - no error.
    uint8_t error {0};
    // Questions count in query (request).
    uint16_t q_count;
    // Answers counr in respond.
    uint16_t a_count;
};

struct DnsPkgQuery
{
    DnsPkgQuery(const std::string & n, DnsQType t, uint16_t c = 1)
        :name(n),
         type(t),
         cls(c)
    {    }

    // Domain name or ip.
    std::string name;
    // Query type (A,MX,PTR).
    DnsQType type;
    // Query class (default - IN (1)).
    uint16_t cls;
};

struct DnsPkgAnswer
{
    // Requested name.
    std::string req_name;
    // Record type (A,MX,PTR).
    DnsQType type;
    // Record class (default - IN (1)). !!Ignored!!
    uint16_t cls {1};
    // Record ttl in cache.
    uint32_t ttl;
    // Size of answer data in this record.
    uint16_t dsize;
    // MX record have preference.
    uint16_t preference {0};
    // Answered name (or IP).
    std::string answer;

};

struct DnsRequest
{
    // Request header
    DnsPkgHeader header;
    // Queries list.
    std::vector<DnsPkgQuery> qlist;
};

struct DnsRespond
{
    // Respond header.
    DnsPkgHeader header;
    // Queries list in respond.
    std::vector<DnsPkgQuery> qlist;
    // Answers list.
    std::vector<DnsPkgAnswer> alist;
};

using DnsRespondPtr = std::unique_ptr<DnsRespond>;

class DnsUIBase;

using DnsUIPtr = std::unique_ptr<DnsUIBase>;
}
#endif // DNSDATATYPES_HPP
