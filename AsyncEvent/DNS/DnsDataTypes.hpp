#ifndef DNSDATATYPES_HPP
#define DNSDATATYPES_HPP

#include <string>
#include <cstring>
#include <stdint.h>
#include <vector>
#include <cmath>
namespace dns {

// Max size of UDP DNS package.
const size_t max_DNS_pkg_size = 512;

struct DnsPkgHeaderMap
{
    /*
     * Identifier: A 16-bit identification field generated by the device that creates the
     * DNS query. It is copied by the server into the response, so it can be used by that
     * device to match that query to the corresponding reply received from a DNS server.
     * This is used in a manner similar to how the Identifier field is used in many of the
     * ICMP message types.
     */
    char ident[2] {0, 0};
    /*
     * Message flags.
     * See Dnsflag enum.
     */
    char flags[2] {0, 0};
    /*
     * QDcount
     * Question Count:
     * Specifies the number of questions in the Question section of the message.
     */
    char QDcount[2] {0, 0};
    /*
     * ANcount
     * Answer Record Count:
     * Specifies the number of resource records in the Answer section of the message.
     */
    char ANcount[2] {0, 0};
    /*
     * NScount
     * Authority Record Count:
     * Specifies the number of resource records in the Authority section of the message.
     */
    char NScount[2] {0, 0};
    /*
     * ARcount
     * Additional Record Count:
     * Specifies the number of resource records in the Additional section of the message.
     */
    char ARcount[2] {0, 0};
};

/*
 * Dnsflag describes bits in 16bits DNS flags.
 * Bits:
 * 0 - Query/Response. Differentiates between queries and responses.
 * 1-4 - Operation code. Standart query - 0.
 * 5 - AA Authoritative Answer Flag: This bit is set to 1 in a response to indicate that
 * the server that created the response is authoritative for the zone in which the domain
 * name specified in the Question section is located. If it is 0, the response is non-authoritative.
 * 6 - Truncated. When set to 1, indicates that the message was truncated due to its length being
 * longer than the maximum permitted for the type of transport mechanism used (512 bytes in UDP).
 * Need use TCP connection.
 * 7 - Recursion Desired: When set in a query, requests that the server receiving the query attempt
 * to answer the query recursively, if the server supports recursive resolution. The value of this
 * bit is not changed in the response.
 * 8 - Recursion Available: Set to 1 or cleared to 0 in a response to indicate whether the server
 * creating the response supports recursive queries. This can then be noted by the device that
 * sent the query for future use.
 * 9-11 - Reserved. Set to zero.
 * 12-16 - Error code. 0 - no error. > 0 - error.
 */
enum class DnsFlag
{
    QR = 0,
    AA = 5,
    TC = 6,
    RD = 7,
    RA = 8,
};

// Type of DNS request.
enum class DnsQType
{
    A = 1,
    PTR = 12,
    MX = 15
};

// Utils struct. Read/write/generate/parse/... DNS packages.
struct DnsUtils
{
    // Convert sizeof(ResT) bytes from bufer to unsigned integral type ResT.
    // Pointer remains at the same position.
    template <typename ResT>
    static ResT buff_read(const char * pt)
    {
        ResT result = 0;
        for (int i = 0; i < sizeof(ResT); ++i)
        {
            result += static_cast<ResT>(static_cast<unsigned char>(pt[i])) * pow(256, sizeof(ResT) - i - 1);
        }
        return result;
    }
    // Convert sizeof(ResT) bytes from bufer to unsigned integral type ResT.
    // Moves the pointer to sizeof(ResT) bytes forward.
    template <typename ResT>
    static ResT buff_step_read(const char *&cursor)
    {
        ResT result = buff_read<ResT>(cursor);
        cursor += sizeof(ResT);
        return result;
    }
    // Write sizeof(ResT) bytes from unsigned integral type ResT to buffer in dns format.
    // Pointer remains at the same position.
    template <typename ResT>
    static void buff_write(char * pt, ResT val)
    {
        for (int i = 0; i < sizeof(ResT) - 1; ++i)
        {
            pt[i] = static_cast<char>(val / pow(256, sizeof(ResT) - i - 1));
        }
        pt[sizeof(ResT) - 1] = static_cast<char>(val % 256);
    }
    // Write sizeof(ResT) bytes from unsigned integral type ResT to buffer in dns format.
    // Moves the pointer to sizeof(ResT) bytes forward.
    template <typename ResT>
    static void buff_step_write(char *&cursor, ResT val)
    {
        buff_write(cursor, val);
        cursor += sizeof(ResT);
    }

    // Return DNS pkg bool flag.
    static bool get_flag(const char * ch, const DnsFlag flag_num);

    // Set DNS pkg bool flag.
    static void set_flag(char * ch, const DnsFlag flag_num);

    // Get DNS answer error from flags.
    static uint16_t get_error(const char * flag);

    // Get string domain from DNS data set. Return offset first byte after reading name.
    static void buff_step_read_qdn(const char *dns_pkg, const char *&cursor, std::string & result);

    // Convert domain to package format and write result directly in buffer.
    // Return size of the data, written to buffer.
    static void write_step_qdn_to_buff(const std::string &dname, char *&_res);

    // Convert string IP to .in-addr.arpa QDN.
    static std::string ip_to_arpa(const std::string &ip);

    // Generate random ID for DNS pkg ident.
    static uint16_t rand_qid();

    // Read 4 bytes ip to string. Move cursor.
    static std::string ip_step_read(const char *&cursor);

    // Validate IP v4 address.
    static bool is_ip_v4(const std::string & ip);

    // Validate IP v4 address.
    static bool is_fqdn(const std::string & name);
};

struct DnsPkgHeader
{
    // Pkg ID.
    uint16_t id;
    // Flags section:
    // Request/respond flag.
    bool f_req_resp {false};
    // 4 bits! Standart 0 (default).
    uint8_t optcode {0};
    // Authoritative Answer.
    bool f_auth_answer {false};
    // Truncation - message was truncated (if out of max pkg size. 512 bytes in udp).
    bool f_truncated {false};
    // Recursion Desired. Ask server to do query recursively.
    bool f_recursive_d {false};
    // Recursion Available. Recursive query support (in server respond).
    bool f_recursive_avail {false};
    // Error code. 0 - no error.
    uint8_t error {0};
    // Questions count in query (request).
    uint16_t q_count;
    // Answers counr in respond.
    uint16_t a_count;
};

struct DnsPkgQuery
{
    // Domain name or ip.
    std::string name;
    // Query type (A,MX,PTR).
    DnsQType type;
    // Query class (default - IN (1)).
    uint16_t cls {1};
};

struct DnsPkgAnswer
{
    // Requested name.
    std::string req_name;
    // Record type (A,MX,PTR).
    DnsQType type;
    // Record class (default - IN (1)). !!Ignored!!
    uint16_t cls {1};
    // Record ttl in cache.
    uint32_t ttl;
    // Size of answer data in this record.
    uint16_t dsize;
    // MX record have preference.
    uint16_t preference {0};
    // Answered name (or IP).
    std::string answer;

};

class DnsRequest
{
public:
    // Write DNS request package to buffer (direct write).
    // Buffer must have enough free space (512 bytes recomended).
    size_t buff_fill(void * buffer);
    // Generate request data for @name and @t.
    size_t get_id() const;

    bool gen_request(const std::string & name, DnsQType t);

private:
    // Request header.
    DnsPkgHeader header;
    // Queries list.
    std::vector<DnsPkgQuery> qlist;
};

class DnsRespond
{
public:
    // Parse DNS respond in buffer. Size is determined automatically.
    // req_id used to compare respont and request. 0 - don't check (not recomended).
    bool parse_respond(const void * buffer, uint16_t req_id);

    std::vector<DnsPkgAnswer> get_answers_list();

private:
    // Answer error. 0 - no error. 1 - no respond.
    uint16_t error{1};

    DnsPkgHeader header;
    // Queries list in respond.
    std::vector<DnsPkgQuery> qlist;
    // Answers list.
    std::vector<DnsPkgAnswer> alist;
};

}
#endif // DNSDATATYPES_HPP
